全局作用域：编写在script标签内的代码；在页面打开时创建，关闭时销毁，在页面的任意部分都可以访问；其中有一个全局对象window，可以直接使用，它代表浏览器的窗口；创建的变量都会作为window对象的属性保存
变量的声明提前：使用var关键字声明的变量，会在所有的代码执行前被声明（不是被赋值，赋值还是在var处）；如果声明变量时不使用var关键字，则不会被提前
函数的声明提前：使用函数声明创建的函数(function xxx(){})会在所有的代码执行前被创建（不只是声明，也包括其中的内容），可以在函数调用之后写；而使用函数表达式创建的函数(var xxx=function(){};)，只会将xxx变量声明，不会提前创建函数内容，如果在函数调用之后写会报错

函数作用域：调用函数时创建的作用域，函数执行完后销毁；每调用一次就创建一个新的函数作用域，它们之间相互独立；在函数作用域中可以访问并修改全局作用域中的变量（不需传参，可以直接用变量名取到），但全局不能访问函数作用域的变量；调变量时，函数内会优先寻找函数作用域内变量，要是没有才向上一级作用域中找，直到全局作用域中也没有就报错
在函数中访问全局变量：window.a
函数作用域中也有声明提前的特性，即用var声明的变量会在函数中所有代码执行前被声明，使用函数声明创建的函数会在函数中所有的代码执行前被创建；函数内声明新变量时不用var，就会自动将其声明为全局变量

函数中使用形参就相当于在函数作用域中声明了变量：
function xxx(a){a=100;}相当于function xxx(a){var a=a; a=100;}不会改变全局中传入的变量

ES6--let不存在变量提前，且作用在块级作用域
在ES5中，变量提前与函数作用域可能造成不合理的后果：
var tmp = '你好';
function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}
f(); //// undefined
此代码原意是if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量，应该输出'你好'。但if内的tmp因为变量声明提前，覆盖了外层的tmp变量，且因为if不可能执行，无法赋值
function f1() {
  let n = 20;
  if (true) {
    let n = 10;
  }
  console.log(n); //20
}
使用let，外层代码块不受内层代码块的影响，该思想与c里面的变量作用域相似，都是哪里声明哪里使用，不会越级

const的作用域与let命令相同：只在声明所在的块级作用域内有效；const命令声明的常量也是不提升，只能在声明的位置后面使用；const声明的常量，也与let一样不可重复声明
差别在于const一旦声明，就必须立即初始化，不能以后再赋值；let声明的变量可以改变，值和类型都可以改变，而const声明的常量不可以改变；
注意：对于数组和对象这中变量保存内存地址的类型，const只保证变量名指向的地址不变，并不保证该地址的数据不变